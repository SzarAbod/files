<!DOCTYPE html>
<html>

<head>
    <script src="https://unpkg.com/pdf-lib"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 30px;
            background-color: #f4f7f6;
            color: #333;
        }

        .container {
            position: relative;
            max-width: 800px;
            margin: 0 auto;
            background: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 5px;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 16px;
            margin-bottom: 10px;
        }

        button {
            padding: 10px 20px;
            margin-right: 10px;
            margin-top: 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #startButton {
            background-color: #28a745;
            color: white;
        }

        #startButton:hover {
            background-color: #218838;
        }

        #downloadButton {
            background-color: #007bff;
            color: white;
            display: none;
        }

        #downloadButton:hover {
            background-color: #0056b3;
        }

        #linkSelection {
            margin-top: 25px;
            padding: 15px;
            border: 1px dashed #ced4da;
            background-color: #e9ecef;
            border-radius: 8px;
        }

        #linkSelection h3 {
            margin-top: 0;
            color: #495057;
            border-bottom: 1px solid #ced4da;
            padding-bottom: 8px;
            margin-bottom: 10px;
        }

        .lesson-item {
            display: block;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .lesson-item:hover {
            background-color: #dee2e6;
        }

        .lesson-item input {
            margin-right: 8px;
        }

        #downloadArea {
            margin-top: 25px;
            padding: 15px;
            border: 1px solid #007bff;
            background-color: #e6f0ff;
            border-radius: 8px;
            display: none;
            text-align: center;
        }

        #downloadArea button {
            background-color: #ffc107;
            color: #333;
            margin: 10px;
        }

        #downloadArea button:hover {
            background-color: #e0a800;
        }

        #loadingOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }

        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #007bff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #loadingText {
            margin-top: 15px;
            font-size: 1.1em;
            color: #007bff;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="downloadArea">
            <h3>تم الانتهاء</h3>
            <button onclick="triggerDownload('unsolved')">تحميل الملف الغير محلول</button>
            <button onclick="triggerDownload('solved')">تحميل الملف المحلول</button>
        </div>

        <label for="subjectName">اسم المادة:</label>
        <input type="text" id="subjectName">

        <label for="courseUrl">الرابط:</label>
        <input type="text" id="courseUrl">
        <br>

        <button id="startButton" onclick="startScraping()">بدا البحث</button>
        <button id="downloadButton" onclick="processSelectedLinks()">تحميل الملفات</button>

        <div id="linkSelection">
            <p>ادخل اسم المادة ثم الرابط واضغط على "بدا البحث" لبدا البحث</p>
        </div>

        <pre id="log" style="display: none;"></pre>

        <div id="loadingOverlay">
            <div class="spinner"></div>
            <div id="loadingText">جار التحميل...</div>
        </div>
    </div>

    <script>
        let lessonLinks = [];
        let unsolvedPdfBytes = null;
        let solvedPdfBytes = null;

        const MAX_RETRIES = 3;
        const RETRY_DELAY_MS = 500;

        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        function setLoading(isLoading, text = "") {
            const overlay = document.getElementById("loadingOverlay");
            const logElement = document.getElementById("log");

            if (isLoading) {
                overlay.style.display = "flex";
                document.getElementById("loadingText").textContent = text;
                logElement.textContent = "";
            } else {
                overlay.style.display = "none";
            }
        }

        function logToHidden(msg) {
            document.getElementById("log").textContent += msg + "\n";
        }

        async function withRetry(asyncFn, url) {
            let lastError;
            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                try {
                    return await asyncFn(url);
                } catch (error) {
                    lastError = error;
                    if (attempt < MAX_RETRIES) {
                        await delay(RETRY_DELAY_MS);
                    }
                }
            }
            throw new Error(`Failed after ${MAX_RETRIES} attempts: ${lastError.message}`);
        }

        async function _fetchHtml(url) {
            const proxyUrl = "https://corsproxy.io/?url=" + encodeURIComponent(url);
            const response = await fetch(proxyUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            return new DOMParser().parseFromString(text, "text/html");
        }

        const fetchHtml = (url) => withRetry(_fetchHtml, url);

        async function _downloadPdf(url) {
            const proxyUrl = "https://corsproxy.io/?url=" + encodeURIComponent(url);
            const res = await fetch(proxyUrl);
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            return await res.arrayBuffer();
        }

        const downloadPdf = (url) => withRetry(_downloadPdf, url);

        function downloadBlob(bytes, filename) {
            if (!bytes) {
                return;
            }
            const blob = new Blob([bytes], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function triggerDownload(type) {
            const subjectName = document.getElementById('subjectName').value.trim();

            if (!subjectName) {
                alert("ادخل اسم المادة");
                return;
            }

            let bytes;
            let filenameSuffix;

            if (type === 'unsolved') {
                bytes = unsolvedPdfBytes;
                filenameSuffix = "غير محلول";
            } else if (type === 'solved') {
                bytes = solvedPdfBytes;
                filenameSuffix = "محلول";
            } else {
                return;
            }

            if (bytes) {
                // Remove any characters that are illegal or problematic in filenames
                const cleanSubjectName = subjectName.replace(/[\\/:*?"<>|]/g, '-');
                const filename = `${cleanSubjectName} ${filenameSuffix}.pdf`;
                downloadBlob(bytes, filename);
            } else {
                alert(`No ${type} PDF data found or ready.`);
            }
        }

        function extractSolvedPDF(doc) {
            const el = doc.querySelector(".tutor-iconic-btn.tutor-iconic-btn-secondary.tutor-stretched-link");
            return el ? el.getAttribute("href") : null;
        }

        function extractUnsolvedPDF(doc) {
            const iframe = doc.querySelector("iframe");
            return iframe ? iframe.src : null;
        }

        async function mergePdfs(urls) {
            const validUrls = urls.filter(url => url);

            if (validUrls.length === 0) {
                return null;
            }

            const downloadPromises = validUrls.map(async (url) => {
                try {
                    const data = await downloadPdf(url);
                    logToHidden(`Download success: ${url.substring(0, 30)}...`);
                    return data;
                } catch (error) {
                    logToHidden(`Download failed: ${url.substring(0, 30)}... Error: ${error.message}`);
                    return null;
                }
            });

            const pdfBuffers = await Promise.all(downloadPromises);

            const successfulBuffers = pdfBuffers.filter(buffer => buffer !== null);

            if (successfulBuffers.length === 0) {
                return null;
            }

            const mergedPdf = await PDFLib.PDFDocument.create();
            logToHidden(`Merging ${successfulBuffers.length} PDFs...`);

            for (const buffer of successfulBuffers) {
                try {
                    const pdf = await PDFLib.PDFDocument.load(buffer);
                    const pages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
                    pages.forEach(p => mergedPdf.addPage(p));
                } catch (error) {
                    logToHidden(`Error loading PDF buffer: ${error.message}`);
                }
            }
            return await mergedPdf.save();
        }

        function selectLinks(links) {
            const selectionDiv = document.getElementById("linkSelection");
            selectionDiv.innerHTML = '<h3>اختار الاسابيع التي سوف يتم تحميلها:</h3>';

            links.forEach((link, index) => {
                const label = document.createElement("label");
                label.className = "lesson-item";

                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.name = "lessonLink";
                checkbox.value = index;
                checkbox.checked = true;

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(link.textContent.trim()));
                selectionDiv.appendChild(label);
            });

            document.getElementById("downloadButton").style.display = "inline-block";
        }

        async function startScraping() {
            unsolvedPdfBytes = null;
            solvedPdfBytes = null;
            document.getElementById("downloadArea").style.display = "none";
            document.getElementById("downloadButton").style.display = "none";
            document.getElementById("linkSelection").innerHTML = "<p>Scanning course page...</p>";

            const url = document.getElementById("courseUrl").value;
            const subjectName = document.getElementById('subjectName').value.trim();

            if (!url) {
                alert("ادخل الرابط");
                return;
            }
            if (!subjectName) {
                alert("ادخل اسم المادة");
                return;
            }

            setLoading(true, "يتم البحث...");

            try {
                const mainDoc = await fetchHtml(url);

                lessonLinks = [...mainDoc.querySelectorAll(".tutor-course-topic-item a")];

                if (lessonLinks.length === 0) {
                    document.getElementById("linkSelection").innerHTML = "<p>فشل البحث</p>";
                    setLoading(false);
                    return;
                }

                selectLinks(lessonLinks);

            } catch (error) {
                alert(`Failed to fetch course page: ${error.message}`);
            }
            setLoading(false);
        }

        async function processSelectedLinks() {
            unsolvedPdfBytes = null;
            solvedPdfBytes = null;
            document.getElementById("downloadButton").disabled = true;
            document.getElementById("downloadArea").style.display = "none";

            const selectedIndices = [...document.querySelectorAll('input[name="lessonLink"]:checked')]
                .map(input => parseInt(input.value));

            if (selectedIndices.length === 0) {
                document.getElementById("downloadButton").disabled = false;
                alert("اختار اسبوع واحد على الاقل للمتابعة");
                return;
            }

            setLoading(true, `جار التحميل...`);

            const linksToProcess = selectedIndices.map(index => lessonLinks[index]);

            const unsolvedPDFs = [];
            const solvedPDFs = [];

            const extractionPromises = linksToProcess.map(async (link) => {
                const lessonUrl = link.href;
                try {
                    const doc = await fetchHtml(lessonUrl);
                    return {
                        unsolved: extractUnsolvedPDF(doc),
                        solved: extractSolvedPDF(doc)
                    };
                } catch (error) {
                    logToHidden(`Failed to process lesson page: ${link.textContent.trim()}: ${error.message}`);
                    return { unsolved: null, solved: null };
                }
            });

            const results = await Promise.all(extractionPromises);

            results.forEach(res => {
                if (res.unsolved) unsolvedPDFs.push(res.unsolved);
                if (res.solved) solvedPDFs.push(res.solved);
            });

            unsolvedPdfBytes = await mergePdfs(unsolvedPDFs);

            solvedPdfBytes = await mergePdfs(solvedPDFs);

            if (unsolvedPdfBytes || solvedPdfBytes) {
                document.getElementById("downloadArea").style.display = "block";
            } else {
                alert("Processing failed. No PDF data was successfully merged.");
            }

            document.getElementById("downloadButton").disabled = false;
            setLoading(false);
        }

    </script>
</body>

</html>